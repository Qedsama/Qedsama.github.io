# OJ2 军训排队

## 问题描述
军训时需要将所有同学(包括教官)排成一队，一开始只有教官(编号为1)排在第一个，之后教官会发出如下三种命令：
 
1 x y   编号为y的同学入队，排在编号为x的同学的后面，若要排在队首，则用0表示x

2 x     编号为x的同学报告其后面的同学编号，若要报告队首同学的编号，则用0表示x，若x在队尾，则报告0

3 x     编号为x的同学出队
 
要求对于每次命令2，都输出报告同学后面同学的编号，并最后从头到尾输出队列中同学的编号。
 
## 输入格式
第一行为一个正整数N，表示总共有几条命令

接下来N行中，每行表示一个命令；每行命令中，数字之间用空格隔开

## 输出格式
对于每次命令2，都输出一个编号，用换行隔开

最后从头到尾输出队列，用换行隔开

## 提示

1. 同学编号为小于100000的正整数

2. 命令的条数N为小于200000的正整数

3. 队列中没有人时不会出现命令2和命令3

## 思路

这个问题可以通过使用双向链表来解决。初始时，队列中只有一个教官，即编号为1的同学。我们可以使用两个数组，next和front，来表示每个同学的下一个同学和前一个同学的编号。

next[x]表示编号为x的同学的下一个同学的编号。

front[x]表示编号为x的同学的前一个同学的编号。

初始时，我们设置next[0]为1，表示队首教官，next[1]为50001，表示队尾。队尾的50001是一个哨兵，用来标识队列的末尾。

对于每种命令，我们进行如下处理：

如果是命令1，表示将编号为y的同学插入到编号为x的同学的后面。我们需要更新next和front数组，将x和y的关系正确连接起来。

如果是命令2，表示编号为x的同学要报告其后面的同学的编号。我们直接输出next[x]的值即可，如果next[x]为50001，表示x在队尾，报告0。

如果是命令3，表示编号为x的同学要出队。我们需要更新next和front数组，将x从队列中删除。

最后，在处理完所有命令后，我们可以通过遍历next数组，从队首到队尾依次输出队列中同学的编号。

暴力思路是每次处理命令时，重新构建队列，遍历查找前后同学的关系，然后输出。这种思路的时间复杂度是O(n^2)，因为对于每个命令，都可能需要遍历整个队列来找到前后同学的关系。空间复杂度也较高，因为需要额外的空间来存储队列的状态。

我的代码使用了双向链表的思想，对于每个命令，只需更新next和front数组的对应关系，时间复杂度是O(n)。空间复杂度是O(n)，因为只需要固定大小的两个数组来存储前后同学的关系。

使用双向链表的思想能够有效地解决这个问题，降低了时间复杂度和空间复杂度。这种思路非常适合处理队列的插入和删除操作，是一个高效的解决方案。比如，在一些内存调用优化算法的实现（如LRU缓存）中，就用到这样的思路。（友情链接：https://leetcode.cn/problems/lru-cache/?envType=daily-question&envId=Invalid+Date）


## 源码

```cpp

#include<cstdio>
unsigned short next[50002];
unsigned short front[50002];
void print(){
    int k=0;
    while(next[k]!=50001){
        printf("%d\n",next[k]);
        k=next[k];
    }
}
int main(){
    int n;scanf("%d",&n);
    next[0]=1;
    next[1]=50001;
    front[1]=0;
    front[50001]=1;
    for(int i=0;i<n;i++){
        int op;
        scanf("%d",&op);
        if(op==1){
            int x,y;scanf("%d%d",&x,&y);
            front[next[x]]=y;
            next[y]=next[x];
            next[x]=y;
            front[y]=x;
        }else if(op==2){
            int x;scanf("%d",&x);
            printf("%d\n",next[x]==50001?0:next[x]);
        }else{
            int x;scanf("%d",&x);
            next[front[x]]=next[x];
            front[next[x]]=front[x];
        }
    }
    print();
}

```