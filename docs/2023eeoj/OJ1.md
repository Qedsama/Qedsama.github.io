# OJ1 丢失的练习册

## 问题描述

开学了，阳光小学准备给每个学生发放三本练习册。为了方便发放，每本练习册上都印上了学生的学号。然而，运输过程中由于道路的颠簸，原本捆绑整齐的练习册散落一地，司机师傅再将练习册堆叠在一起时，学号已经完全打乱。更糟糕的是，当他清点练习册总数时，发现少了一本，为了尽快弄清楚丢失的是印有哪位学生学号的练习册，司机师傅只好拿出本子，一个个记录每个练习册上的学号。聪明的你能够通过编程的方法找到是印有哪个同学学号的练习册丢失了吗？

## 输入格式
第1行为学生的总数：N；
第2到第3N行为司机师傅记录的练习册上的学号；
注意：没有丢失练习册的学号会出现3次，而丢失练习册的学号只会出现2次。

## 输出格式
丢失练习册上对应的学号

## 提示

### 1. 取值范围
N的取值范围为[1,1×106]的整数；
学生学号的取值范围为[0, 2×109]的整数；
 
### 2. 测试样例
1~3测试样例N<1×104;
4~5测试样例1×104<=N<=5×105；
6~10测试样例5×105<N<=1×106；
 
### 3. 时间和空间
本道OJ本身并不难，但对程序运行的时间和空间有较为严格的要求，时间需要为O(n)，空间为O(1)才能通过所有的测试样例，请同学们从算法效率的角度出发，选择合适的算法。

## 思路

这个问题可以使用位运算来解决。我们知道，对于一个整数，它的每个二进制位上的数字要么是0，要么是1。如果一个学号出现了3次，那么它的每个二进制位上的数字的总和应该是3的倍数，因为每个学生的学号都被记录了3次，所以在每个二进制位上，该学号对应的位上的数字总和应该是3的倍数。

因此，我们可以遍历所有学号，统计每个二进制位上的数字总和，然后找到那些不是3的倍数的位，这些位上的数字就是丢失的学号对应位上的数字。最后将这些数字组合起来就得到了丢失的学号。

在源码中，首先创建一个数组sum来记录每个二进制位上的数字总和。然后，遍历所有学号，对每个学号进行位运算，将每个二进制位上的数字累加到sum数组中。最后，根据sum数组中的数字构建丢失的学号。


暴力思路是遍历所有学号，然后统计每个学号出现的次数，最后找到出现次数为2的学号。这种思路的时间复杂度是O(n^2)，因为需要遍历所有学号来统计它们的出现次数。空间复杂度也较高，需要额外的空间来存储每个学号的出现次数。


我的代码的时间复杂度是O(n)，其中n是学生的总数，因为只需遍历所有学号一次。空间复杂度是O(1)，因为只使用了一个固定大小的sum数组来存储每个二进制位上的数字总和，不随输入规模n的增加而增加额外的空间。


## 源码

``` cpp
#include<cstdio>
int sum[32];
int main(){
    int n;scanf("%d",&n);
    for(int i=0;i<3*n-1;i++){
        int id;scanf("%d",&id);
        int x=0;
        while(id){
            sum[x]+=id&1;
            id>>=1;
            x++;
        }
    }
    int ans=0;
    for(int i=31;i>=0;i--){
        if(sum[i]%3!=0)ans+=1;
        if(i)ans<<=1;
    }
    printf("%d",ans);
}
```  